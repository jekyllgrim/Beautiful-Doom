Class BDoomWeapon : Weapon abstract {	
	protected bool picked; //has this gun been picked up before?
	protected int offsetTics; // current camera sway timer
	protected double maxOffsetTics; // starting point for the timer
	protected double offsetAngle; // the target angle for the camera sway
	protected double offsetPitch;
	protected double currentAngleOffset; // how much has the camera already been offset?
	protected double currentPitchOffset;
	property maxOffsetTics : maxOffsetTics;
	property offsetTics : offsetTics;
	
	protected sound reloadsound;	//used as a sound cue in background reload
	property reloadsound : reloadsound;
	
	protected int NonselTimer; //counts how long the weapon was deselected, used for automatic background reload
	protected int AutoReloadTime; //the value that NonselTimer is compared to
	property AutoReloadTime : AutoReloadTime;		
	protected Class<Ammo> magammo;		//magazine ammo used by Modern Guns
	property magammo : magammo;
	protected int magammogive;			//amount of magazine ammo given at first pickup (full mag for most weapons except Rocket Launcher)
	property magammogive : magammogive;
	
	protected transient CVar c_muzzle;	
	protected transient CVar c_blackgloves;
	protected bool wasempty;			//used in reload animations to keep track of whether reload was dry (affects animations)
	protected bool dontforcebob;		//if false, weapons will bob all the time
	property dontforcebob : dontforcebob;
	//keep track of states:
	protected state mreload;
	protected state mready;
	
	protected double preKickSpeed;
	
	Default {  
		BDoomWeapon.AutoReloadTime 60;
		BDoomWeapon.maxOffsetTics 1; //required default values for A_CameraSway. Otherwise it'll crash due to division by zero
		BDoomWeapon.offsetTics -1;
	}	
	//Selects between regular weapon sprite and the one with black gloves:
	action void BD_SetSprite(name sprite1, name sprite2) {
		let psp = player.FindPSprite(OverlayID());
		if (!psp)
			return;
		if (invoker.c_blackgloves.GetBool() == false)
			psp.sprite = GetSpriteIndex(sprite1);
		else
			psp.sprite = GetSpriteIndex(sprite2);
	}
	
	//Removes PSprite. Can be called both from state and from DoEffect and allows removing multiple psprite IDs, not a from-to range.
	action void BD_ClearPSprite(int layer1, int layer2 = 0, int layer3 = 0, int layer4 = 0, int layer5 = 0) {
		array <int> layers = { layer1, layer2, layer3, layer4, layer5 };
		PlayerInfo plr;
		if (self && self.player)
			plr = self.player;
		else if (invoker.owner && invoker.owner.player)
			plr = invoker.owner.player;
		else
			return;
		for (int i = layers.Size() - 1; i >= 0; i--) {
			if (layers[i] != 0) {
				plr.SetPSprite(layers[i],null);
			}
		}
		return;
	}
	
	// Camera sway function by josh771
	action void A_CameraSway(double aoffset, double poffset, int tics) {
		invoker.offsetTics = tics;
		invoker.maxOffsetTics = tics;
		
		invoker.offsetAngle = aoffset;
		invoker.offsetPitch = poffset;

		invoker.currentAngleOffset = 0.0;
		invoker.currentPitchOffset = 0.0;
	}
	
	action void BD_ModernPunch(int damage, int berserkdamage = 0, Class<Actor> pufftype = null, Class<Actor> berserkpuff = null, int range = 0) {
		A_CustomPunch (
			(FindInventory("PowerStrength") && berserkdamage != 0) ? berserkdamage : damage,
			norandom: true,
			flags: 0, //don't use ammo
			pufftype: (FindInventory("PowerStrength" /*"ModernBerserk_Regen"*/) && berserkpuff) ? berserkpuff : pufftype,
			range : range
		);
	}
	
	action void BD_FireBullets(double spread_horz = 0, double spread_vert = 0, int numbullets = 1, int damage = 1, sound vanillasnd = "", sound enhancedsnd = "") {
		sound snd =  (enhancedsnd && bdoom_weapons == 1) ? enhancedsnd : vanillasnd;
		A_StartSound(snd);
		Class<Actor> trac = bdoom_tracers ? "BD_BulletTracer" : "";
		A_FireBullets (spread_horz, spread_vert, numbullets, damage, "BD_EnBulletPuff",FBF_USEAMMO|FBF_NORANDOMPUFFZ,missile:trac,spawnheight:0);
	}
	
	enum BD_Layers {
		PSP_MAG 			= -3,
		PSP_GUN2 			=  2,
		PSP_GUN3 			=  3,
		PSP_HEAT 			=  5,
		PSP_KICK 			= -10,
		PSP_REDDOT 		= -4,
		PSP_MFLASH 		= -5,
		PSP_EFLASH 		=  12,
		PSP_LIGHTS 		=  10,
		PSP_HLIGHTS 		=  11,
		PSP_CHAINBLOOD 	=  30,
		PSP_CHAINBLOODR 	=  31,
		PSP_CHAINBLOODG 	=  32,
		PSP_CHAINBLOODB 	=  33
	};
	
	enum BD_SoundChannels {
		CHAN_CHGSPIN	= 9,
		CHAN_CHGCOOL	= 10
	}
	
	//Make sure player's magazine isn't empty when a weapon is first picked up (for Modern Guns):
	override void AttachToOwner(actor other) {
		super.AttachToOwner(other);
		if (!owner)
			return;
		if (owner.player) {
			let plr = owner.player;
			c_muzzle = CVar.GetCVar("bdoom_muzzle",plr);
			c_blackgloves = CVar.GetCVar("bdoom_blackgloves",plr);
		}
		if (picked)
			return;
		int ama = (magammogive > 0) ? magammogive : 100; //give either full mag, or however much is specified with magammo property
		owner.GiveInventory(magammo,ama);
		picked = true;
	}
	
	//override bool CheckAmmo(int fireMode, bool autoSwitch, bool requireAmmo = false, int ammocount = -1) {
		//if (bdoom_weapons == 2 && 

	//an analog of A_WeaponReady that makes sure Reload state is unaccessible if mag is full or you have no reserve ammo:
	action void BD_WeaponReady (bool allowSecondary = false, bool allowReload = true, bool allowKick = true) {
		int flags = 0;
		if (allowReload && invoker.ammo1 && invoker.ammo2 && (invoker.ammo2 != invoker.ammo1) && (invoker.ammo2.amount > 0) && (invoker.ammo1.amount < invoker.ammo1.maxamount))
			flags |= WRF_ALLOWRELOAD;
		if (!allowSecondary)
			flags |= WRF_NOSECONDARY;
		if (allowKick)
			flags |= WRF_ALLOWUSER1;		
		A_WeaponReady (flags);
	}

	action void BD_Overlay(int layer = 0, statelabel statename = null, int flags = 0, double xofs = 0, double yofs = 0, int offsetflags = 0, int style = 0, double alpha = 0) {
		if (layer == 0 || !statename)
			return;
		A_Overlay(layer, statename, 0);
		if (flags != 0)
			A_OverlayFlags(layer, flags, true);
		if (xofs != 0 && yofs != 0)
			A_OverlayOffset(layer, xofs,yofs, offsetflags);
		if (style)
			A_OverlayRenderstyle(layer,style);
		if (alpha != 0)	{
			A_OverlayFlags(layer,PSPF_Alpha|PSPF_FORCEALPHA,true);
			A_OverlayAlpha(layer,alpha);
		}
	}

	action void BD_Reload()	{
		if (invoker.ammo1 && invoker.ammo2) {
			while (invoker.ammo2.amount > 0 && invoker.ammo1.amount < invoker.ammo1.maxamount) {
				TakeInventory(invoker.ammo2.GetClass(),1);
				GiveInventory(invoker.ammo1.GetClass(),1);
			}
		}
	}

	//Casing spawn function with math by Marisa Kirisame (see mk_matrix)
	action actor A_Eject(class<Actor> itemtype, double xofs = 0, double yofs = 0, double zofs = 0, double xvel = 0, double yvel = 0, double zvel = 0) {
		if (!player || !player.mo)
			return null;
		PlayerInfo plr = player;
		PlayerPawn pmo = player.mo;
		Vector3 ofs = pmo.pos+(0,0,plr.viewheight-GetFloorTerrain().footclip);
		Vector3 x, y, z;
		[x, y, z] = Matrix4.getaxes(pmo.pitch,pmo.angle,pmo.roll);
		let c = Spawn(itemtype,ofs+x*xofs+y*yofs-z*zofs);
		if (c) {
			c.vel = x*xvel+y*yvel+z*zvel;
			c.target = self;
			c.angle = angle;
			return c;
		}
		return null;
	}
	
	override void PostBeginPlay() {
		super.PostBeginPlay();
		mreload = FindState("Reload.Modern");
		if (!mreload)
			mreload = FindState("Reload");
		if (!mreload)
			mreload = FindState("ForcedCool");
		mready = FindState("Ready.Modern");
	}
		
	override void DoEffect() {
		Super.DoEffect();
		if (!owner || !owner.player)
			return;
		/*int bgl = CVar.GetCvar("bdoom_blackgloves",owner.player).GetInt();
		Console.Printf("%s | blackgloves var: %b | blackgloves CVAR: %b",GetClassName(),c_blackgloves.GetInt(),bgl);*/
		if (magammo) {
			if (bdoom_weapons == 2)
				Ammo1 = ammo(owner.FindInventory(magammo));
			else
				Ammo1 = ammo(owner.FindInventory(ammotype1));
		}
		if (!bdoom_replaceweapons)
			self.SelectionOrder = self.default.SelectionOrder+50000;
		else
			self.SelectionOrder = self.default.SelectionOrder;
		//Console.Printf("x: %d, y: %d, z:%d", owner.pos.x,owner.pos.y,owner.pos.z);
		//allow switching weapons during reload:
		if(bdoom_weapons == 2) {
			let psp = owner.player.FindPSprite(PSP_Weapon);
			if (psp && (InStateSequence(psp.curstate,mreload)))
				owner.player.WeaponState |= WF_WEAPONSWITCHOK;
		}
		if (CVar.FindCVar('bdoom_weaponbobstyle').GetBool() == true) {
			BobRangeX = 0.2;
			BobRangeY = 0.2;
			BobStyle = 5;
			BobSpeed = 2.0;
			//force bobbing all the time:
			if (owner.player.readyweapon && owner.player.readyweapon == self && !dontforcebob)
				owner.player.WeaponState |= WF_WEAPONBOBBING;
		}
		else {
			BobRangeX = 1.0;
			BobRangeY = 1.0;
			BobStyle = 0;
			BobSpeed = 1.0;
		}
		//CameraSway in action	
		if (offsetTics >= 0) {
			double phase = (offsetTics / maxOffsetTics) * 90.0;
			double newAngleOffset = (cos(phase) * offsetAngle);
			double newPitchOffset = (cos(phase) * offsetPitch);
			double finalAngle = (owner.angle - currentAngleOffset) + newAngleOffset;
			double finalPitch = (owner.pitch - currentPitchOffset) + newPitchOffset;
			currentAngleOffset = newAngleOffset;
			currentPitchOffset = newPitchOffset;
			owner.A_SetAngle(finalAngle, SPF_INTERPOLATE);
			owner.A_SetPitch(finalPitch, SPF_INTERPOLATE);
			offsetTics--;
		}
		
	//QUICK KICK
		//if player presses +user1 (default Q and Mouse4)
		if 	((owner.player.cmd.buttons & BT_USER1) && !(owner.player.oldbuttons & BT_USER1)) {
			let psp = owner.player.FindPSprite(PSP_WEAPON);
			let kicks = owner.player.FindPSprite(PSP_KICK);
			if(!psp || bdoom_weapons != 2  || kicks) //if dead, or not Modern guns selected, or is already kicking
				return;
			//do this if used from Ready: will not only kick in overlay but will also move the weapon aside
			else if	(InStateSequence(psp.curstate, mready) )
				owner.player.setPSprite(PSP_Weapon,ResolveState("QKick"));
			//do this if used during Reload: weapon sprite will stay the same, kick will be shown and executed independently in overlay
			else if (InStateSequence(psp.curstate, mreload))
				owner.player.setPSprite(PSP_KICK,FindState("QuickKick"));
		}
	//BACKGROUND RELOAD
		if (bdoom_weapons != 2 || !bdoom_autoreload || !ammo1 || !ammo2 || (ammo1 == ammo2))
			return;
		if (owner.player.readyweapon == self || ammo1.amount == ammo1.maxamount || ammo2.amount < 1) {
			NonselTimer = 0;
			return;
		}
		if (NonselTimer < AutoReloadTime)
			NonselTimer++;
		else {
			while (ammo2.amount > 0 && ammo1.amount < ammo1.maxamount)	{
				owner.TakeInventory(ammo2.GetClass(),1);
				owner.GiveInventory(ammo1.GetClass(),1);
			}
			if (owner.player == players[consoleplayer])
				Console.Printf("%s reloaded",GetTag());
			owner.A_StartSound(reloadsound,slot:CHAN_AUTO,flags:CHAN_NOPAUSE,volume:0.5,attenuation:20);
		}			
	}

	states	{
		QKick:
			#### # 0 A_Overlay(PSP_KICK,"QuickKick");
			#### ###### 1 A_WeaponOffset(7,4,WOF_ADD);
			#### ############ 1 A_WeaponOffset(-3.5,-2,WOF_ADD);
			#### # 0 A_jump(256,"Ready");
			wait;
		QuickKick:
			TNT1 A 0 {
				invoker.preKickSpeed = speed;
				A_OverlayOffset(OverlayID(),28,32);
				A_OverlayFlags(OverlayID(),PSPF_ADDBOB|PSPF_ADDWEAPON,false);
				A_OverlayFlags(OverlayID(),PSPF_FLIP|PSPF_MIRROR|PSPF_PLAYERTRANSLATED,true);
				if (player.onGround) {
					if (CountInv("Modernberserk_Regen") > 0)
						speed = invoker.preKickSpeed * 0.5;
					else
						speed = invoker.preKickSpeed * 0.25;
				}
			}
			KICK AB 1;
			TNT1 A 0 { 
				if(CountInv("PowerStrength") > 0)
					A_StartSound("Mweapons/fist/heavyswing",slot:CHAN_AUTO);
				else
					A_StartSound("Mweapons/fist/swing",slot:CHAN_AUTO);
				A_CameraSway(0.0,3.0,5);
			}
			KICK CD 1;
			KICK EF 1 {
				if (CountInv("Modernberserk_Regen") > 0)
					A_Recoil(-6);
				else
					A_Recoil(-3);
			}
			KICK G 3 {
				if (CountInv("Modernberserk_Regen") > 0) {
					A_Recoil(-5);
				}
				else {
					A_Recoil(-1.5);
				}
				BD_ModernPunch(10*frandom(3,5.5), berserkdamage: 20*frandom(4.5,6), pufftype:"BD_ModernKickPuff", berserkpuff:"BD_ModernKickPuff_Berserk", range: 85);
			}
			TNT1 A 0 A_CameraSway(0.0,-3.0,8);
			KICK HDC 2;
			TNT1 A 0 {
				speed = invoker.preKickSpeed;
			}
			KICK BA 3;
			TNT1 A 7 ;
			stop;
		DryReload:
			#### # 8 {
				A_ClearRefire();
				A_StartSound("Mweapons/dry",0);
			}
			#### # 0 A_Jump(256,"Reload");
			wait;
		LoadSprites:
			MUZ1 ABCDEFGH 0;
			MUZ2 ABCD 0;
			MUZ3 ABCD 0;
			MUZ4 ABCD 0;
			MUZ6 ABCD 0;
			MUZ7 ABCDEF 0;
			MUZ8 ABCDEF 0;
			PZ11 ABC 0;
			PZ12 ABC 0;
			PZ21 ABC 0;
			PZ22 ABC 0;
			PZ31 ABC 0;
			PZ32 ABC 0;
			ROR1 ABCDEFGHIJKL 0;
			ROR2 ABCDEFGHIJKL 0;
			ROR3 ABCDEFGHIJKL 0;
			RORR ABCDE 0;
			RORS ABCDE 0;
			RORN ABC 0; RORE ABC 0; RORV ABC 0; RORT ABC 0;
			PLHE Z 0;
			PLH1 ABCDEFGHIJ 0;
			PLH2 ABCDEFGHIJ 0;
			BBGG ABCD 0;
			stop;
			
	}
}



//////////////



Class BD_RealBullet : FastProjectile {
	protected vector3 SpawnPos; //where the bullet was shot from
	double bulletdamage; 		//the actual damage value
	double falloffstrength; 	//how quickly the damage is reduced during travel
	double mindamage; 			//minimum damage value at any distance
	int falloffdistance; 		//distance at which the falloff begins
	int bulletspeed; 			//actual bullet speed (since 'speed' property is used to determine spawn distance only)
	property bulletdamage : bulletdamage;
	property bulletspeed : bulletspeed;
	property falloffstrength : falloffstrength;
	property falloffdistance : falloffdistance;
	property mindamage : mindamage;
	Default {
		BD_RealBullet.bulletDamage 10;
		BD_RealBullet.bulletspeed 200;
		BD_RealBullet.FalloffDistance 1024;
		BD_RealBullet.falloffstrength 0.3;
		BD_RealBullet.mindamage 1;
		+BLOODSPLATTER
		+HITTRACER
		radius 1;
		height 1;
		alpha 0.75;
		speed 64;
		renderstyle "add";
		seesound "null";
		deathsound "null";
		DamageFunction CalculateDamage();
	}
	override void PostBeginPlay() {
		super.PostBeginPlay();
		if (target)
			SpawnPos = target.pos;
	}
	//whizz sound snippet by phantombeta
	override void Tick () {
		if (isFrozen())
			return;
		Vector3 oldPos = pos;		
		Super.Tick();
		if (bdoom_debris && waterlevel > 2 && level.Vec3Diff(oldPos, SpawnPos).length() > 100) {
			Vector3 path = level.vec3Diff( pos, oldPos );
			double distance = path.length() / 4; //this determines how far apart the particles are
			Vector3 direction = path / distance;
			int steps = int( distance );			
			for( int i = 0; i < steps; i++ )  {
				if (level.Vec3Diff(oldPos, SpawnPos).length() > 16) {
					actor mo = Spawn("BD_WaterBubble", oldPos );
					if (mo)
						mo.vel = (frandom(-0.5,0.5),frandom(-0.5,0.5),frandom(-0.5,0.5));
				}
				oldPos = level.vec3Offset( oldPos, direction );
			}
		}
		if (!playeringame [consolePlayer])
			return;		
		let curCamera = players [consolePlayer].camera;
		if (!curCamera) // If the player's "camera" variable is null, set it to their PlayerPawn
			curCamera = players [consolePlayer].mo;
		if (!curCamera) // If the player's PlayerPawn is null too, just stop trying
			return;
		if (CheckIfCloser (curCamera, 192))
			A_StartSound("weapons/tracerwhizz",slot:CHAN_WEAPON,flags:CHANF_DEFAULT,1.0,attenuation:8);
	}
	double CalculateDamage() {
		int ddamage;
		int FalloffFactor = 0;
		double ddistance = level.Vec3Diff(pos, SpawnPos).length() - falloffdistance;
		//Essentially falloff factor is retroactively applied "every tick", so there are fewer falloff steps for faster projectiles:
		if (ddistance > 0)
			FalloffFactor = int (ddistance / bulletspeed);
		//falloffstrength is by how much it's reducedâ€”this is applied to damage "every tick"
		ddamage = clamp(bulletdamage*(falloffstrength**FalloffFactor),mindamage,100);
		//console.printf("distance: %d Damage: %d",level.Vec3Diff(pos, SpawnPos).length(),ddamage);
		return ddamage;
	}
		
	states {
		Spawn:
			TNT1 A 2 NoDelay {
				vel = vel.unit() * bulletspeed;
			}
			PUFF A 1 {
				if (waterlevel > 2) {
					sprite = GetSpriteIndex("WATR");
					bBRIGHT = false;
					for (int i = 20; i > 0; i--) {
						A_SpawnItemEx(
							"BD_WaterBubble",
							//xofs:i*16,
							xvel:frandom[wtr](-1,1),yvel:frandom[wtr](-1,1),zvel:frandom[wtr](-1,1)
						);
					/*	A_SpawnParticle(
							"DDDDDD",
							flags:SPF_RELPOS|SPF_RELANG,
							lifetime:100,
							size:2,
							xoff: i*16,
							velx:frandom[wtr](-1,1),vely:frandom[wtr](-1,1),velz:frandom[wtr](-1,1),
							startalphaf:0.5,
							fadestepf:-1,
							sizestep:1.01
						);*/
					}
				}
				else {
					sprite = GetSpriteIndex("PUFF");
					bBRIGHT = true;
				}
			}
			wait;
		XDeath:
			TNT1 A 1 {
				let mon = BDoomMonster(tracer);
				if (mon)
					mon.hitheight = pos.z - mon.pos.z;
			}
			stop;
		Death:
			TNT1 A 1 A_SpawnItemEx("BD_EnBulletPuff",flags:SXF_TRANSFERPOINTERS);
			stop;
	}
}

Class BD_BulletTracer : BD_RealBullet {
	Default {
		BD_RealBullet.bulletspeed 256;
		-ACTIVATEIMPACT;
		-ACTIVATEPCROSS;
		+BLOODLESSIMPACT;
		damage 0;
		radius 4;
		height 4;
	}    
	states {
		Death:
			TNT1 A 1;
			stop;
	}
}

Class BD_PistolBullet : BD_RealBullet {
	Default {
		BD_RealBullet.bulletDamage 15;
		BD_RealBullet.bulletspeed 170;
		BD_RealBullet.FalloffDistance 512;
		BD_RealBullet.falloffstrength 0.9;
	}
}

Class BD_RifleBullet : BD_RealBullet {
	Default {
		BD_RealBullet.bulletDamage 15;
		BD_RealBullet.bulletspeed 230;
		BD_RealBullet.FalloffDistance 640;
		BD_RealBullet.falloffstrength 0.93;
	}
}

Class BD_ShotgunPellet : BD_RealBullet {
	Default {
		BD_RealBullet.bulletDamage 12;
		BD_RealBullet.bulletspeed 140;
		BD_RealBullet.FalloffDistance 400;
		BD_RealBullet.falloffstrength 0.85;
	}
}

// Modern SSG is the only piercing weapon in the mod but it deals damage only once upon contact, not continuously
// Piercing strength depends on enemy health: the "thicker" the enemy is, the harder it is for the bullet to go through them
Class BD_SSGPellet : BD_RealBullet {
	private int ripdepth; 		//how much health it can pierce through
	private actor hitvictim;	//the actor that was hit
	property ripdepth : ripdepth;
	Default {
		BD_SSGPellet.ripdepth 300;
		BD_RealBullet.bulletDamage 12;		
		BD_RealBullet.Bulletspeed 140;
		BD_RealBullet.FalloffDistance 300;
		BD_RealBullet.falloffstrength 0.8;
	}
	override int SpecialMissileHit(actor victim) {
		//deal damage only ONCE even if the pellet rips through
		//first we make sure the vicitm hasn't been hit yet and isn't the shooter:
		if (victim && target && (victim != target) && (victim != hitvictim)) { 
				//reduce ripping ability based on victim's current health (thick monsters are harder to pierce):
				ripdepth -= victim.health; 
				hitvictim = victim;
				bulletdamage = CalculateDamage();
				victim.DamageMobj(self,target,bulletdamage,"normal");
				if (!victim.bNOBLOOD && victim.bSHOOTABLE) {
					if (Distance3D(target) <= 320) {
						let xd = victim.FindState("XDeath");
						if (xd && !InStateSequence(victim.curstate,xd)) {
							if (!victim.FindInventory("BD_SSGGibControl"))
								victim.GiveInventory("BD_SSGGibControl",1);
							let ssgib = BD_SSGGibControl(victim.FindInventory("BD_SSGGibControl"));
							if (ssgib)
								ssgib.dmgtotal -= bulletdamage*2;
							//Console.Printf("%s dmgtotal: %d/%d",victim.GetClassName(),ssgib.dmgtotal,victim.GetGibHealth());
						}
					}
					victim.TraceBleed(bulletdamage,self);
					victim.SpawnBlood(pos,AngleTo(victim),bulletdamage);
				}
			}
		if (ripdepth <= 0)
			return 0;
		return 1;
	}
}


class BD_MuzzleSmoke : BD_BaseSmoke {
	Default {
		alpha 0.5;
		scale 0.05;
		renderstyle 'shaded';
		stencilcolor "FFFFFF";
	}
	override void PostBeginPlay() {
		vel = vel.unit() * frandom(1,3);
		super.PostBeginPlay();
		//wrot = (random[bdsfx](3,10)*randompick(-1,1));
		//frame = random[bdsfx](0,5);
	}
	override void Tick() {
		super.Tick();
		if (isFrozen())
			return;
		vel *= 0.8;
		vel.z = clamp(vel.z*0.85,0.04,0.1);
		A_FadeOut(0.0003);
		scale *= 1.02;
	}
	states {
	Spawn:
		SMOK AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRR 1 {
		}
		stop;

	}
}	


//***************
// EMPTY CASINGS
//***************

Class BD_BaseEmptyCasing : BD_SmallDebris {
	protected name spawnsprite;
	property spawnsprite : spawnsprite;
	Default {
		BD_SmallDebris.dbrake 0.75;
		BD_SmallDebris.liquidsound "world/watersplashsmall";
		+ROLLCENTER
		+BOUNCEONFLOORS
		+BOUNCEONWALLS
		renderstyle "normal";
		seesound "none";
		mass 1;
		Radius 1;
		Height 4;
		bouncefactor 0.3;
		wallbouncefactor 0.4;
		Scale 0.15;
	}
	Override Void PostBeginPlay() {
		if(!target) {
			destroy();
			return;
		}
		super.PostBeginPlay();
		wrot = frandom(-18,-24);
		roll = frandom(100,105);
		sprite = GetSpriteIndex(spawnsprite);
	}
	override void BD_HitFloor() {
		if (target && target.bISMONSTER) {
			destroy();
			return;
		}
		//Console.Printf("splash %d",GetFloorTerrain().Splash);
		super.BD_HitFloor();		
	}
	override void Tick() {
		super.Tick();
		if (isFrozen())
			return;
		if (waterlevel > 1) {
			bBOUNCEONFLOORS = false;
			bNOGRAVITY = true;
			if (abs(wrot) > 1)
				wrot *= 0.93;
			if (pos.z > floorz) {
				roll+=wrot;
				vel.z = Clamp(vel.z - 0.1,-0.1,5);
				vel.xy *= 0.92;
			}
		}
		else
			bBOUNCEONFLOORS = true;
			bNOGRAVITY = false;
			gravity = default.gravity;
	}		
	states {
	Spawn:
		#### AABBCCBBAABBCCBB 1 {
			roll += wrot;
			wrot *= 0.99;
		}
		loop;
	Death:
		#### # -1 {
			if (waterlevel == 0) {
				roll = frandom(-8,8);
				bSPRITEFLIP = random(0,1);
				A_StartSound(bouncesound);
			}
		}
		stop;
	loadsprites:
		CAS1 ABC 0;	CAS2 ABC 0;	CAS3 ABC 0;
		stop;
	}
}


Class BD_PistolCasing : BD_BaseEmptyCasing {
	Default {
		Scale 0.11;
		BD_BaseEmptyCasing.spawnsprite 'CAS1';
		bouncesound "weapons/casing";
	}
}

Class BD_ShotgunCasing : BD_BaseEmptyCasing { 
	Default {
		Scale 0.2;
		BD_BaseEmptyCasing.spawnsprite 'CAS2';
		bouncesound "weapons/shotgunshells";
	}
}

Class BD_ChaingunCasing : BD_BaseEmptyCasing { 
	Default {
		BD_BaseEmptyCasing.spawnsprite 'CAS3';
		bouncefactor 0.35;
		wallbouncefactor 0.4;
		Scale 0.15;
		bouncesound "chaingun/casing";
	}
}
