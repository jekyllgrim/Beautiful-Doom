class BD_Replacementhandler : EventHandler {

	int gameCompatType;

	enum EGameCompatValues {
		GC_DOOM,
		GC_PAINSLAYER,
		GC_KDIKDIZD,
		GC_ALICE
	}

	int GetGameCompat() {
		int game = GC_DOOM;
		
		string pkc = "PK_BaseActor";
		class<Actor> pk = pkc;
		if (pk) {
			game |= GC_PAINSLAYER;
		}
		
		string alc = "ToM_BaseActor";
		class<Actor> al = alc;
		if (al) {
			game |= GC_ALICE;
		}
		
		if (Wads.FindLump("kdikdizd")) {
			game |= GC_KDIKDIZD;
		}
		
		return game;
	}
	
	override void OnRegister() {
		gameCompatType = GetGameCompat();
		//if (gameCompatType & GC_KDIKDIZD)
			//console.printf("Playing Knee-Deep in KDiZD");
	}

	/*	This function is designed to avoid replacing actors that are 
		defined in DEHACKED or their sprites are replaced directly.
		With max compatibility it'll check sprite names in the archives 
		loaded in the game: if it finds that the same sprite lump appears
		more than once, we conclude that one of the archives replaces said 
		sprite directly, and probably for a good reason.
		If that's the case, we'll let the original actor spawn instead of 
		the Beautiful Doom version. This is important for mapsets such as 
		Deus Vult 2, which use a lot of custom decorations with vanilla 
		sprite names.
		Then it'll check for DEHACKED definition (DEHACKED checker by 
		3saster).
		All of this only happens if bdoom_safereplacement CVAR is true 
		(default); otherwise replacement is forced.
	*/
	virtual bool CheckVanillaReplacement (name classname = "", string spriteName = "") {
		if (bdoom_safereplacement <= 0)
			return false;
			
		if (bdoom_safereplacement >= 1 && classname) {
			let event = BD_DEHACKED_Handler(StaticEventHandler.Find("BD_DEHACKED_Handler"));
			if (event && event.IsDehacked(classname))
				return true;
		}
		
		if (bdoom_safereplacement >= 2 && spriteName) {
			int firstLump = Wads.FindLump(spriteName,0,1);
			int nextLump =  Wads.FindLump(spriteName,firstLump +1,1);
			if(nextLump != -1)
				return true;
		}
		
		return false;
	}
	
	// Universal function by Marisa Kirisame that 
	// returns locknumber if the line is locked:
    static clearscope int GetLineLock( Line l ) {
        int locknum = l.locknumber;
        if ( !locknum ) {
            // check the special
            switch ( l.special ) {
            case FS_Execute:
                locknum = l.Args[2];
                break;
            case Door_LockedRaise:
            case Door_Animated:
                locknum = l.Args[3];
                break;
            case ACS_LockedExecute:
            case ACS_LockedExecuteDoor:
            case Generic_Door:
                locknum = l.Args[4];
                break;
            }
        }
        return locknum;
    }
}

class BD_WeaponOverrideHandler : BD_Replacementhandler {

	override void PlayerDied(PlayerEvent e) {
		if (!bdoom_replaceweapons)
			return;
		PlayerInfo player = players[e.PlayerNumber];
		let psp = player.FindPSPrite(PSP_Weapon);
		if (psp && player) {
			for (int i = 1000; i > 1; i--)
				player.SetPSprite(i,null);
			for (int i = -1000; i < 1; i++)
				player.SetPSprite(i,null);
		}
	}
	
	override void PlayerSpawned(PlayerEvent e) {
		let plr = players[e.PlayerNumber].mo;
		if (!plr)
			return;
		if (!plr.FindInventory("BD_OverlayControl"))
			plr.GiveInventory("BD_OverlayControl",1);
		if (!plr.FindInventory("BD_WeaponPickupControl"))
			plr.GiveInventory("BD_WeaponPickupControl",1);
	}

	override void WorldThingSpawned(WorldEvent e) {
		if (!bdoom_replaceitems)
			return;
		if (!(e.thing is "Inventory"))
			return;
		let inv = Inventory(e.thing);
		if (!inv)
			return;
		// These items have no new visuals and only new pickup sounds, so, I insert them via an event handler, without replacing the actual actors
		switch (inv.GetClassName()) {
			case 'Clip' 		: inv.pickupsound = "ammo/clip";			break;
			case 'ClipBox' 	: inv.pickupsound = "ammo/clipbox";		break;
			case 'Shell' 		: inv.pickupsound = "ammo/shells";		break;
			case 'ShellBox' 	: inv.pickupsound = "ammo/shells";		break;
			case 'RocketAmmo' : inv.pickupsound = "ammo/rockets";		break;
			case 'RocketBox' 	: inv.pickupsound = "ammo/rockets";		break;
			case 'Cell' 		: inv.pickupsound = "ammo/cells";		break;
			case 'CellPack' 	: inv.pickupsound = "ammo/cells";		break;
			case 'BackPack' 	: inv.pickupsound = "pickups/backpack";	break;
			case 'RadSuit' 	: inv.pickupsound = "pickups/radsuit";	break;
		}
	}

	// Replaces weapons on the map if the appropriate CVAR is true.
	override void CheckReplacement(ReplaceEvent e) {
		bool notAnotherGameplayMod = !(gameCompatType & GC_PAINSLAYER) && !(gameCompatType & GC_ALICE);
		
		if (bdoom_replaceweapons && notAnotherGameplayMod) {
			switch (e.Replacee.GetClassName()) {
			case 'Berserk':
				e.Replacement = 'BD_Berserk';
				break;
			case 'Fist': 
				e.Replacement = 'BD_Fist';
				break;
			case 'Chainsaw': 
				e.Replacement = 'BD_Chainsaw';
				break;
			case 'Pistol': 
				e.Replacement = 'BD_Pistol';
				break;
			case 'Shotgun':
				e.Replacement = 'BD_Shotgun';
				break;
			case 'SuperShotgun':
				e.Replacement = 'BD_SuperShotgun';
				break;
			case 'Chaingun':
				e.Replacement = 'BD_Chaingun';
				break;
			case 'RocketLauncher':
				e.Replacement = 'BD_RocketLauncher';
				break;
			case 'PlasmaRifle':
				e.Replacement = 'BD_PlasmaRifle';
				break;
			case 'BFG9000':
				e.Replacement = 'BD_BFG9000';
				break;
			}
		}
	}
}

/* Simply replaces actors with modded ones if the appropriate CVAR is true.
Helps to keep the mod compatible with other actor-replacing mods. 
Separate CVARs for each monsters are also supported. */

class BD_ActorOverrideHandler : BD_Replacementhandler {
	
	/*	Play a "skull lock" or "keycard lock" sound
		when activating a locked line, based on
		either the lock number, or the door texture
	*/
	override void WorldLinePreActivated  (worldEvent e) {
		// Get the line and its lock:
		let line = e.ActivatedLine;
		int lock = GetLineLock(line);
		if (lock <= 0)
			return;
		let act = e.thing;
		if (!e.thing.player)
			return;
		// Check if player has keys:
		if (act.CheckKeys(lock,false,quiet:true))
			return;
			
		// Use keycard sound by default:
		sound snd = "world/trycard";
		
		// locks 4-6 are skull-only locks:
		if (lock >= 4 && lock <= 6)
			snd = "world/tryskull";
			
		// Locks 129-131 are default Doom locks,
		// they don't differentiate between
		// card and skull keys, so we'll try to
		// check if the texture on it is wooden:
		else if (lock >= 129 && lock <= 131) {
			let side = line.sidedef[0];
			let texname = TexMan.GetName(side.GetTexture(0));
			// If the texture has 'WOOD' in its name,
			// it's wooden:
			bool wooden = texname.IndexOf("WOOD") >= 0;
			if (!wooden) {
				// Otherwise, if it's any of these 3,
				// it's also wooden:
				static const name SkullDoors[] = {
					'BIGDOOR5',
					'BIGDOOR6',
					'BIGDOOR7'
				};
				for (int i = 0; i < SkullDoors.Size(); i++) {
					wooden = texname == SkullDoors[i];
					if (wooden)
						break;
				}
			}
			if (wooden)
				snd = "world/tryskull";
		}
		// Play the sound on the activator:
		act.A_StartSound(snd,CHAN_AUTO,CHANF_UI|CHANF_LOCAL);
	}
	
	static const name KDIKDIZD_Exceptions[] = {
		'HangNoGuts', //Crushable script helper
		'ArchVile', //Hell Warrior
		'Rocket', //Hell Warrior Shield
		'ArchVileFire', //Soul Reaper
		'Revenant', //Soul Harvester
		'RevenantTracer', //Soul Harvester Fireball
		'Fatso', //Wargrin
		'WolfensteinSS', //Rapid Fire Trooper
		'ChaingunGuy', //KZDIZD Chaingunner
		'DeadLostSoul', //Suicide Bomber
		'CommanderKeen', //Shadow
		'Arachnotron', //Dark Caco
		'ArachnotronPlasma', //Shadow projectile
		'BossBrain', //Dark Imp
		'Stalagtite',
		'BloodyTwitch', //Bruiser
		'LostSoul', //Bruiser Fire
		'FatShot', //Bruiser Projectile
		'BrainStem', //Mauler
		'HangTLookingDown', //Nightmare Demon
		'HangTSkull', //Zombieman no ammo drop
		'BlueCard',
		'RedCard',
		'YellowCard',
		'YellowSkull', //Green Keycard
		'RedSkull', //Orange keycard
		'BlueSkull', //Silver keycard
		'PainElemental', //Dead miner
		'HangTNoBrain', //Ceiling light
		'HangTLookingUp', //Sitting corpse
		'ColonGibs', //Jackhammer
		'HangBNoBrain', //Yellow Ceiling Light
		'ShortBlueTorch', //Stalactite
		'ShortGreenTorch', //Stage Light
		'Meat4', //long sign
		'SmallBloodPool', //non-solid floor lamp
		'BossEye', //gray dead marine
		'BossTarget', //pink dead marine
		'TechLamp', //bronze lamp
		'GreenTorch', //reflected torch
		'Meat5', //Hissy plush
		'GibbedMarineExtra', //rolling chair
		'BurningBarrel', //Seismic Bomb faux pickup
		'CyberDemon', //green tree
		'LightAmp', //Teleporting Berserk
		'SpiderMastermind', //Resurrector
		'Meat3', //Rain
		'BlueTorch', //WallTorch
		'Meat2', //Explosion Generator
		'Megasphere', //Seismic Timed Explosion
		'BFGExtra' //Quiet Imp
	};
	
	bool IsKDiKDiZDException(name classname) {
		for (int i = 0; i < KDIKDIZD_Exceptions.Size(); i++) {
			if (KDIKDIZD_Exceptions[i] && KDIKDIZD_Exceptions[i] ==classname)
				return true;
		}
		return false;
	}
	
	// Override that does a KDIKDIZD-specific check
	// that circumvents the normal DEHACKED/spritename
	// checks:
	override bool CheckVanillaReplacement (name classname, string spriteName) {
		if (bdoom_safereplacement <= 0)
			return false;
		
		// If playing Knee-Deep in KDiZD:
		if (gameCompatType & GC_KDIKDIZD) {
			// If class name is provided, check it against
			// the exceptions:
			if (classname)
				return IsKDiKDiZDException(classname);
			// Otherwise ignore the sprite name check:
			else
				return false;
		}
		
		return super.CheckVanillaReplacement(classname, spriteName);
	}
	
	// This performs the actual conditional actor replacement:
	override void CheckReplacement(ReplaceEvent e) {
		
		name rname = e.Replacee.GetClassName();
	
		if (bdoom_blood) {	
			switch (rname) {
			case 'Blood' :
				e.Replacement = 'BD_Blood';
				break;
			case 'BloodSplatter' :
				e.Replacement = 'BD_Blood';
				break;
			case 'AxeBlood' :
				e.Replacement = 'BD_BloodSpurt';
				break;
			}
		}
		
		bool DehReplaced = CheckVanillaReplacement(rname);
		if (DehReplaced)
			return;
		
		if (bdoom_replacemonsters) {			
			switch (rname) {
			case 'Zombieman': 
				if (bdoom_Zombieman) 			
					e.Replacement = 'BD_Zombieman'; 			
				break;
			case 'ShotgunGuy': 
				if (bdoom_ShotgunGuy) 
					e.Replacement = 'BD_ShotgunGuy'; 	
				break;
			case 'ChaingunGuy': 
				if (bdoom_ChaingunGuy)
					e.Replacement = 'BD_ChaingunGuy';
				break;
			case 'WolfensteinSS': 
				if (bdoom_WolfensteinSS)
					e.Replacement = 'BD_WolfensteinSS'; 
				break;
			case 'DoomImp': 
				if (bdoom_DoomImp)
					e.Replacement = 'BD_DoomImp';
				break;
			case 'Demon': 
				if (bdoom_Demon)
					e.Replacement = 'BD_Demon';
				break;
			case 'Spectre': 
				if (bdoom_Spectre)
					e.Replacement = 'BD_Spectre';
				break;
			case 'Cacodemon':
				if (bdoom_Cacodemon)
					e.Replacement = 'BD_Cacodemon';
				break;
			case 'PainElemental': 
				if (bdoom_PainElemental)
					e.Replacement = 'BD_PainElemental';
				break;
			case 'LostSoul': 
				if (bdoom_LostSoul)
					e.Replacement = 'BD_LostSoul';
				break;
			case 'Revenant': 
				if (bdoom_Revenant)
					e.Replacement = 'BD_Revenant';
				break;
			case 'Arachnotron': 
				if (bdoom_Arachnotron)
					e.Replacement = 'BD_Arachnotron'; 
				break;
			case 'Fatso': 
				if (bdoom_Fatso)
					e.Replacement = 'BD_Fatso';
				break;
			case 'HellKnight': 
				if (bdoom_HellKnight)
					e.Replacement = 'BD_HellKnight';
				break;
			case 'BaronOfHell': 
				if (bdoom_BaronOfHell)
					e.Replacement = 'BD_BaronOfHell';
				break;
			case 'ArchVile': 
				if (bdoom_ArchVile)
					e.Replacement = 'BD_ArchVile';
				break;
			case 'Cyberdemon': 
				if (bdoom_Cyberdemon)
					e.Replacement = 'BD_Cyberdemon';
				break;
			case 'SpiderMastermind':
				if (bdoom_SpiderMastermind)
					e.Replacement = 'BD_SpiderMastermind';
				break;
			case 'BossBrain': 
				if (bdoom_IconOfSin) 
					e.Replacement = 'BD_BossBrain';
				break;
			case 'SpawnShot': 
				if (bdoom_IconOfSin)
					e.Replacement = 'BD_SpawnShot';
				break;
		// Decorative corpses are handled alongside monsters
		// to make sure they match visually:
			case 'DeadZombieman': 
				if (!CheckVanillaReplacement(spriteName:"POSSL0") && bdoom_Zombieman)
					e.Replacement = 'BD_DeadZombieman';
				break;
			case 'DeadShotgunGuy': 
				if (!CheckVanillaReplacement(spriteName:"SPOSL0") && bdoom_ShotgunGuy)
					e.Replacement = 'BD_DeadShotgunGuy';
				break;
			case 'DeadDoomImp':
				if (!CheckVanillaReplacement(spriteName:"TROOM0") && bdoom_DoomImp)
					e.Replacement = 'BD_DeadDoomImp';
				break;
			case 'DeadDemon':
				if (!CheckVanillaReplacement(spriteName:"SARGN0") && bdoom_Demon)
					e.Replacement = 'BD_DeadDemon';
				break;
			case 'DeadCacodemon':
				if (!CheckVanillaReplacement(spriteName:"HEADL0") && bdoom_Cacodemon)
					e.Replacement = 'BD_DeadCacodemon';
				break;
			case 'DeadLostSoul': 
				if (bdoom_LostSoul)
					e.Replacement = 'BD_DeadLostSoul';
				break;
			}
		}
		
		if (bdoom_projectiles > 0) {
			switch (rname) {
			case 'DoomImpBall': 
				e.Replacement = 'BD_DoomImpBall';
				break;
			case 'CacodemonBall': 
				e.Replacement = 'BD_CacodemonBall';
				break;
			case 'FatShot': 
				e.Replacement = 'BD_FatShot';
				break;
			case 'RevenantTracer': 
				e.Replacement = 'BD_RevenantTracer';
				break;
			case 'BaronBall':
				e.Replacement = 'BD_BaronBall';
				break;
			case 'Plasmaball':
				e.Replacement = 'BD_Plasmaball';
				break;
			case 'ArachnotronPlasma':
				e.Replacement = 'BD_ArachnotronPlasma';
				break;
			case 'Rocket':
				e.Replacement = 'BD_Rocket';
				break;
			}
		}
		
		bool notAnotherGameplayMod = !(gameCompatType & GC_PAINSLAYER) && !(gameCompatType & GC_ALICE);
		
		if (bdoom_replaceitems && notAnotherGameplayMod) {
			switch (rname) {
			case 'Blursphere': 
				e.Replacement = 'BD_Blursphere';
				break;
			case 'Soulsphere': 
				e.Replacement = 'BD_Soulsphere';
				break;
			case 'Megasphere': e.Replacement = 'BD_Megasphere'; 				break;
			case 'InvulnerabilitySphere'
				: e.Replacement = 'BD_InvulnerabilitySphere'; 	break;
			case 'Allmap' : 
				e.Replacement = 'BD_Allmap'; 
				break;
			case 'Infrared' : 
				e.Replacement = 'BD_Infrared'; 
				break;
			case 'HealthBonus': 
				e.Replacement = 'BD_HealthBonus'; 
				break;
			case 'ArmorBonus' : 
				e.Replacement = 'BD_ArmorBonus'; 
				break;
			case 'Stimpack' : 
				e.Replacement = 'BD_Stimpack'; 
				break;
			case 'Medikit' : 
				e.Replacement = 'BD_Medikit'; 
				break;
			case 'GreenArmor' : 
				e.Replacement = 'BD_GreenArmor'; 
				break;
			case 'BlueArmor' : 
				e.Replacement = 'BD_BlueArmor'; 
				break;
			case 'RedCard' : 
				e.Replacement = 'BD_RedCard'; 
				break;
			case 'BlueCard' : 
				e.Replacement = 'BD_BlueCard'; 
				break;
			case 'YellowCard' : 
				e.Replacement = 'BD_YellowCard'; 
				break;
			case 'RedSkull' : 
				e.Replacement = 'BD_RedSkull'; 
				break;
			case 'BlueSkull' : 
				e.Replacement = 'BD_BlueSkull'; 
				break;
			case 'YellowSkull': 
				e.Replacement = 'BD_YellowSkull'; 
				break;
			}
		}
		
		if (bdoom_replaceobjects) {
			//e.IsFinal = true;
			name obj = e.Replacee.GetClassName();
			switch (obj) {
					//VICTIMS
				Case 'HangTLookingDown' 	: if (!CheckVanillaReplacement(obj,"HDB3A0"))	e.Replacement = 'BD_HangingTorso'; 		break;
				Case 'HangTLookingUp' 	: if (!CheckVanillaReplacement(obj,"HDB5A0"))	e.Replacement = 'BD_HangingTorso'; 		break;
				Case 'HangTNoBrain' 		: if (!CheckVanillaReplacement(obj,"HDB6A0"))	e.Replacement = 'BD_HangingTorso'; 		break;
				Case 'HangTSkull': if (!CheckVanillaReplacement(obj,"HDB4A0"))	e.Replacement = 'BD_HangingTorso'; 		break;
				Case 'HangBNoBrain' 		: if (!CheckVanillaReplacement(obj,"HDB2A0"))	e.Replacement = 'BD_HangingBody'; 		break;
				Case 'HangNoGuts': if (!CheckVanillaReplacement(obj,"HDB1A0"))	e.Replacement = 'BD_HangingBody'; 		break;
				Case 'BloodyTwitch'		: if (!CheckVanillaReplacement(obj,"GOR1A0"))	e.Replacement = 'BD_BloodyTwitch'; 		break;
				Case 'NonSolidTwitch'		: if (!CheckVanillaReplacement(obj,"GOR1A0"))	e.Replacement = 'BD_NonsolidTwitch'; 		break;				
				Case 'Meat2'				: if (!CheckVanillaReplacement(obj,"GOR2A0"))	e.Replacement = 'BD_Meat2'; 				break;
				Case 'Meat3'				: if (!CheckVanillaReplacement(obj,"GOR3A0"))	e.Replacement = 'BD_Meat3'; 				break;
				Case 'Meat4'				: if (!CheckVanillaReplacement(obj,"GOR4A0"))	e.Replacement = 'BD_Meat4'; 				break;
				Case 'Meat5'				: if (!CheckVanillaReplacement(obj,"GOR5A0"))	e.Replacement = 'BD_Meat5'; 				break;				
				Case 'NonsolidMeat2'		: if (!CheckVanillaReplacement(obj,"GOR2A0"))	e.Replacement = 'BD_NonsolidMeat2'; 		break;
				Case 'NonsolidMeat3'		: if (!CheckVanillaReplacement(obj,"GOR3A0"))	e.Replacement = 'BD_NonsolidMeat3'; 		break;
				Case 'NonsolidMeat4'		: if (!CheckVanillaReplacement(obj,"GOR4A0"))	e.Replacement = 'BD_NonsolidMeat4';		break;
				Case 'NonsolidMeat5'		: if (!CheckVanillaReplacement(obj,"GOR5A0"))	e.Replacement = 'BD_NonsolidMeat5';		break;
				Case 'DeadStick'			: if (!CheckVanillaReplacement(obj,"POL1A0"))	e.Replacement = 'BD_DeadStick';			break;
				Case 'LiveStick'			: if (!CheckVanillaReplacement(obj,"POL6A0"))	e.Replacement = 'BD_LiveStick';			break;
				Case 'HeadOnAStick'		: if (!CheckVanillaReplacement(obj,"POL4A0"))	e.Replacement = 'BD_HeadOnAStick';		break;
				Case 'HeadsOnAStick'		: if (!CheckVanillaReplacement(obj,"POL2A0"))	e.Replacement = 'BD_HeadsOnAStick';		break;
				Case 'ColonGibs'			: if (!CheckVanillaReplacement(obj,"POB1A0") && bdoom_gibs)	e.Replacement = 'BD_ColonGibs';		break;
				Case 'SmallBloodPool'		: if (!CheckVanillaReplacement(obj,"POB2A0") && bdoom_blood)	e.Replacement = 'BD_SmallBloodPool';	break;
					//MISC
				case 'TeleportFog' 		: if (!CheckVanillaReplacement(obj,"TFOGA0"))	e.Replacement = 'BD_TeleportFog';			break;
				case 'ExplosiveBarrel' 	: if (!CheckVanillaReplacement(obj,"BAR1A0"))	e.Replacement = 'BD_ExplosiveBarrel';		break;
				case 'EvilEye': if (!CheckVanillaReplacement(obj,"CEYEA0"))	e.Replacement = 'BD_EvilEye';				break;
				case 'FloatingSkull' 		: if (!CheckVanillaReplacement(obj,"FSKUA0"))	e.Replacement = 'BD_FloatingSkull';		break;
				case 'HeartColumn' 		: if (!CheckVanillaReplacement(obj,"COL5A0"))	e.Replacement = 'BD_HeartColumn';			break;
				case 'BigTree': if (!CheckVanillaReplacement(obj,"TRE2A0"))	e.Replacement = 'BD_BigTree';				break;
				case 'TorchTree': if (!CheckVanillaReplacement(obj,"TRE1A0"))	e.Replacement = 'BD_TorchTree';			break;
					//LIGHTS
				case 'GreenTorch': if (!CheckVanillaReplacement(obj,"TGRNA0"))	e.Replacement = 'BD_TallTorch_Green';		break;
				case 'RedTorch': if (!CheckVanillaReplacement(obj,"TREDA0"))	e.Replacement = 'BD_TallTorch_Red';			break;
				case 'BlueTorch': if (!CheckVanillaReplacement(obj,"TBLUA0"))	e.Replacement = 'BD_TallTorch_Blue';			break;
				case 'ShortGreenTorch'	: if (!CheckVanillaReplacement(obj,"SMGTA0"))	e.Replacement = 'BD_ShortTorch_Green';		break;
				case 'ShortRedTorch' 		: if (!CheckVanillaReplacement(obj,"SMRTA0"))	e.Replacement = 'BD_ShortTorch_Red';			break;
				case 'ShortBlueTorch' 	: if (!CheckVanillaReplacement(obj,"SMBTA0"))	e.Replacement = 'BD_ShortTorch_Blue';		break;
				case 'Candlestick' 		: if (!CheckVanillaReplacement(obj,"CANDA0"))	e.Replacement = 'BD_Candlestick';			break;
				case 'Candelabra': if (!CheckVanillaReplacement(obj,"CBRAA0"))	e.Replacement = 'BD_Candelabra';			break;
				case 'BurningBarrel' 		: if (!CheckVanillaReplacement(obj,"FCANA0"))	e.Replacement = 'BD_BurningBarrel';		break;
				case 'Techlamp': if (!CheckVanillaReplacement(obj,"TLMPA0"))	e.Replacement = 'BD_Techlamp';				break;
				case 'Techlamp2': if (!CheckVanillaReplacement(obj,"TLP2A0"))	e.Replacement = 'BD_Techlamp2';			break;
				case 'Column' 				: if (!CheckVanillaReplacement(obj,"COLUA0"))	e.Replacement = 'BD_Column';				break;
			}
		}
	}
	
	// This override tells the game which of the original 
	// monsters the modded monster replaces. Necessary 
	// for "hardcoded" effects such as Map07 or E1M8
	override void Checkreplacee(ReplacedEvent e) {
		if (!bdoom_replacemonsters)
			return;
		name monst = e.Replacement.GetClassName();
		switch (monst) {
			case 'BD_Zombieman': if (bdoom_Zombieman) 			e.Replacee = 'Zombieman'; 			break;
			case 'BD_ShotgunGuy': if (bdoom_ShotgunGuy) 			e.Replacee = 'ShotgunGuy'; 		break;
			case 'BD_ChaingunGuy' 		: if (bdoom_ChaingunGuy) 			e.Replacee = 'ChaingunGuy'; 		break;
			case 'BD_WolfensteinSS'		: if (bdoom_WolfensteinSS) 		e.Replacee = 'WolfensteinSS'; 	break;
			case 'BD_DoomImp' 				: if (bdoom_DoomImp) 				e.Replacee = 'DoomImp'; 			break;
			case 'BD_Demon' 				: if (bdoom_Demon) 				e.Replacee = 'Demon'; 				break;
			case 'BD_Spectre' 				: if (bdoom_Spectre) 				e.Replacee = 'Spectre'; 			break;
			case 'BD_Cacodemon': if (bdoom_Cacodemon) 			e.Replacee = 'Cacodemon'; 			break;
			case 'BD_PainElemental'		: if (bdoom_PainElemental) 		e.Replacee = 'PainElemental'; 	break;
			case 'BD_LostSoul'				: if (bdoom_LostSoul) 			e.Replacee = 'LostSoul'; 			break;
			case 'BD_Revenant': if (bdoom_Revenant) 			e.Replacee = 'Revenant'; 			break;
			case 'BD_Arachnotron' 		: if (bdoom_Arachnotron) 			e.Replacee = 'Arachnotron'; 		break;
			case 'BD_Fatso' 				: if (bdoom_Fatso) 				e.Replacee = 'Fatso'; 				break;
			case 'BD_HellKnight': if (bdoom_HellKnight) 			e.Replacee = 'HellKnight'; 		break;
			case 'BD_BaronOfHell' 		: if (bdoom_BaronOfHell) 			e.Replacee = 'BaronOfHell'; 		break;
			case 'BD_ArchVile': if (bdoom_ArchVile) 			e.Replacee = 'ArchVile'; 			break;
			case 'BD_Cyberdemon': if (bdoom_Cyberdemon) 			e.Replacee = 'Cyberdemon'; 		break;
			case 'BD_SpiderMastermind'	: if (bdoom_SpiderMastermind) 	e.Replacee = 'SpiderMastermind';	break;
			case 'BD_BossBrain': if (bdoom_IconOfSin) 			e.Replacee = 'BossBrain';			break;
			case 'BD_SpawnShot': if (bdoom_IconOfSin) 			e.Replacee = 'SpawnShot';			break;
		}
	}
}

Class BD_LiquidTexturesHandler : BD_Replacementhandler {
	
	private bool bd_liquidtex;
	private bool bd_goretex;
	
	override void WorldTick() {
		if (level.time % 35 == 0)
			return;
		if (bd_liquidtex != bdoom_liquidtextures)
			BD_ReplaceLiquidTextures();
		bd_liquidtex = bdoom_liquidtextures;
		if (bd_goretex != bdoom_goretextures)
			BD_ReplaceGoreTextures();
		bd_goretex = bdoom_goretextures;
	}
	
	void BD_ReplaceTextures(string from, string to, int surface = 0) {
		int tex1 = int(TexMan.CheckForTexture(from, TexMan.Type_Any, TexMan.TryAny));
		if (tex1 < 0)
			return;
		int tex2 = int (TexMan.CheckForTexture(to, TexMan.Type_Any, TexMan.TryAny));
		if (tex2 < 0)
			return;
		if (surface >= 2)
			level.ReplaceTextures(from, to, TexMan.NOT_FLOOR|TexMan.NOT_CEILING);
		else if (surface == 1)
			level.ReplaceTextures(from, to, TexMan.NOT_BOTTOM|TexMan.NOT_MIDDLE|TexMan.NOT_TOP);
		else
			level.ReplaceTextures(from, to, 0);
	}
	
	// This replaces gore texures (SP_DUDEs) with custom gore textures based on Beautiful gore decorations (if decorations are replaced too)
	static const name BD_SP_DUDE1[] = { "textures/BD_DUDE1a.png", "textures/BD_DUDE1b.png" };
	static const name BD_SP_DUDE2[] = { "textures/BD_DUDE2a.png", "textures/BD_DUDE2b.png" };
	static const name BD_SP_DUDE4[] = { "textures/BD_DUDE4a.png", "textures/BD_DUDE4b.png", "textures/BD_DUDE4c.png" };
	static const name BD_SP_DUDE5[] = { "textures/BD_DUDE5a.png", "textures/BD_DUDE5b.png", "textures/BD_DUDE5c.png", "textures/BD_DUDE5d.png" };
	static const name BD_SP_DUDE7[] = { "textures/BD_DUDE7a.png", "textures/BD_DUDE7b.png", "textures/BD_DUDE7c.png" };
	static const name BD_SP_DUDE8[] = { "textures/BD_DUDE8a.png", "textures/BD_DUDE8b.png", "textures/BD_DUDE8c.png" };
	void BD_ReplaceGoreTextures() {
		if (bdoom_goretextures) {
			BD_ReplaceTextures("SP_DUDE1", BD_SP_DUDE1[random[goretexreplace](0,1)],0);
			BD_ReplaceTextures("SP_DUDE2", BD_SP_DUDE2[random[goretexreplace](0,1)],0);
			BD_ReplaceTextures("SP_DUDE4", BD_SP_DUDE4[random[goretexreplace](0,2)],0);
			BD_ReplaceTextures("SP_DUDE5", BD_SP_DUDE5[random[goretexreplace](0,3)],0);
			BD_ReplaceTextures("SP_DUDE7", BD_SP_DUDE7[random[goretexreplace](0,2)],0);
			BD_ReplaceTextures("SP_DUDE8", BD_SP_DUDE8[random[goretexreplace](0,2)],0);
		}
		else {
			BD_ReplaceTextures("textures/BD_DUDE1a.png", "SP_DUDE1",0);
			BD_ReplaceTextures("textures/BD_DUDE1b.png", "SP_DUDE1",0);
			BD_ReplaceTextures("textures/BD_DUDE2a.png", "SP_DUDE2",0);
			BD_ReplaceTextures("textures/BD_DUDE2b.png", "SP_DUDE2",0);
			BD_ReplaceTextures("textures/BD_DUDE4a.png", "SP_DUDE4",0);
			BD_ReplaceTextures("textures/BD_DUDE4b.png", "SP_DUDE4",0);
			BD_ReplaceTextures("textures/BD_DUDE4c.png", "SP_DUDE4",0);
			BD_ReplaceTextures("textures/BD_DUDE5a.png", "SP_DUDE5",0);
			BD_ReplaceTextures("textures/BD_DUDE5b.png", "SP_DUDE5",0);
			BD_ReplaceTextures("textures/BD_DUDE5c.png", "SP_DUDE5",0);
			BD_ReplaceTextures("textures/BD_DUDE5d.png", "SP_DUDE5",0);
			BD_ReplaceTextures("textures/BD_DUDE7a.png", "SP_DUDE7",0);
			BD_ReplaceTextures("textures/BD_DUDE7b.png", "SP_DUDE7",0);
			BD_ReplaceTextures("textures/BD_DUDE7c.png", "SP_DUDE7",0);
			BD_ReplaceTextures("textures/BD_DUDE8a.png", "SP_DUDE8",0);
			BD_ReplaceTextures("textures/BD_DUDE8b.png", "SP_DUDE8",0);
			BD_ReplaceTextures("textures/BD_DUDE8c.png", "SP_DUDE8",0);
		}			
	}
	
	void BD_ReplaceLiquidTextures() {
		if (bdoom_liquidtextures) {
			//lava
			BD_ReplaceTextures("LFALL1","BDT_LFA1",surface: 2);
			BD_ReplaceTextures("LFALL2","BDT_LFA1",surface: 2);
			BD_ReplaceTextures("LFALL3","BDT_LFA1",surface: 2);
			BD_ReplaceTextures("LFALL4","BDT_LFA1",surface: 2);
			BD_ReplaceTextures("LAVA1","BDT_LFA2",surface: 2);
			BD_ReplaceTextures("LAVA2","BDT_LFA2",surface: 2);
			BD_ReplaceTextures("LAVA3","BDT_LFA2",surface: 2);
			BD_ReplaceTextures("LAVA4","BDT_LFA2",surface: 2);
			BD_ReplaceTextures("LAVA1","BDT_LFL",surface: 1);
			BD_ReplaceTextures("LAVA2","BDT_LFL",surface: 1);
			BD_ReplaceTextures("LAVA3","BDT_LFL",surface: 1);
			BD_ReplaceTextures("LAVA4","BDT_LFL",surface: 1);
			//water
			BD_ReplaceTextures("WFALL1","BDT_WFA1",surface: 2);
			BD_ReplaceTextures("WFALL2","BDT_WFA1",surface: 2);
			BD_ReplaceTextures("WFALL3","BDT_WFA1",surface: 2);
			BD_ReplaceTextures("WFALL4","BDT_WFA1",surface: 2);
			BD_ReplaceTextures("FWATER1","BDT_WFA2",surface: 2);
			BD_ReplaceTextures("FWATER2","BDT_WFA2",surface: 2);
			BD_ReplaceTextures("FWATER3","BDT_WFA2",surface: 2);
			BD_ReplaceTextures("FWATER4","BDT_WFA2",surface: 2);
			BD_ReplaceTextures("FWATER1","BDT_WFL",surface: 1);
			BD_ReplaceTextures("FWATER2","BDT_WFL",surface: 1);
			BD_ReplaceTextures("FWATER3","BDT_WFL",surface: 1);
			BD_ReplaceTextures("FWATER4","BDT_WFL",surface: 1);
			//blood
			BD_ReplaceTextures("BFALL1","BDT_BFA1",surface: 2);
			BD_ReplaceTextures("BFALL2","BDT_BFA1",surface: 2);
			BD_ReplaceTextures("BFALL3","BDT_BFA1",surface: 2);
			BD_ReplaceTextures("BFALL4","BDT_BFA1",surface: 2);
			BD_ReplaceTextures("BLOOD1","BDT_BFA2",surface: 2);
			BD_ReplaceTextures("BLOOD2","BDT_BFA2",surface: 2);
			BD_ReplaceTextures("BLOOD3","BDT_BFA2",surface: 2);
			BD_ReplaceTextures("BLOOD4","BDT_BFA2",surface: 2);
			BD_ReplaceTextures("BLOOD1","BDT_BFL",surface: 1);
			BD_ReplaceTextures("BLOOD2","BDT_BFL",surface: 1);
			BD_ReplaceTextures("BLOOD3","BDT_BFL",surface: 1);
			BD_ReplaceTextures("BLOOD4","BDT_BFL",surface: 1);
			//acid
			BD_ReplaceTextures("SFALL1","BDT_AFA1",surface: 2);
			BD_ReplaceTextures("SFALL2","BDT_AFA1",surface: 2);
			BD_ReplaceTextures("SFALL3","BDT_AFA1",surface: 2);
			BD_ReplaceTextures("SFALL4","BDT_AFA1",surface: 2);
			BD_ReplaceTextures("NUKAGE1","BDT_AFA2",surface: 2);
			BD_ReplaceTextures("NUKAGE2","BDT_AFA2",surface: 2);
			BD_ReplaceTextures("NUKAGE3","BDT_AFA2",surface: 2);
			BD_ReplaceTextures("NUKAGE4","BDT_AFA2",surface: 2);
			BD_ReplaceTextures("NUKAGE1","BDT_AFL",surface: 1);
			BD_ReplaceTextures("NUKAGE2","BDT_AFL",surface: 1);
			BD_ReplaceTextures("NUKAGE3","BDT_AFL",surface: 1);
			BD_ReplaceTextures("NUKAGE4","BDT_AFL",surface: 1);
			//slime 1
			BD_ReplaceTextures("SLIME01","BDT_SFA1",surface: 2);
			BD_ReplaceTextures("SLIME02","BDT_SFA1",surface: 2);
			BD_ReplaceTextures("SLIME03","BDT_SFA1",surface: 2);
			BD_ReplaceTextures("SLIME04","BDT_SFA1",surface: 2);
			BD_ReplaceTextures("SLIME01","BDT_SFL1",surface: 1);
			BD_ReplaceTextures("SLIME02","BDT_SFL1",surface: 1);
			BD_ReplaceTextures("SLIME03","BDT_SFL1",surface: 1);
			BD_ReplaceTextures("SLIME04","BDT_SFL1",surface: 1);
			//slime 2
			BD_ReplaceTextures("SLIME05","BDT_SFA2",surface: 2);
			BD_ReplaceTextures("SLIME06","BDT_SFA2",surface: 2);
			BD_ReplaceTextures("SLIME07","BDT_SFA2",surface: 2);
			BD_ReplaceTextures("SLIME08","BDT_SFA2",surface: 2);
			BD_ReplaceTextures("SLIME05","BDT_SFL2",surface: 1);
			BD_ReplaceTextures("SLIME06","BDT_SFL2",surface: 1);
			BD_ReplaceTextures("SLIME07","BDT_SFL2",surface: 1);
			BD_ReplaceTextures("SLIME08","BDT_SFL2",surface: 1);
			//Boss brain
			BD_ReplaceTextures("DBRAIN1","BDT_DBRN",surface: 2);
			BD_ReplaceTextures("DBRAIN2","BDT_DBRN",surface: 2);
			BD_ReplaceTextures("DBRAIN3","BDT_DBRN",surface: 2);
			BD_ReplaceTextures("DBRAIN4","BDT_DBRN",surface: 2);
		}
		else {
			//lava
			BD_ReplaceTextures("BDT_LFA1", "LFALL1",surface: 2);
			BD_ReplaceTextures("BDT_LFA2", "LAVA1",surface: 2);
			BD_ReplaceTextures("BDT_LFL", "LAVA1",surface: 1);
			//water
			BD_ReplaceTextures("BDT_WFA1", "WFALL1",surface: 2);
			BD_ReplaceTextures("BDT_WFA2", "FWATER1",surface: 2);
			BD_ReplaceTextures("BDT_WFL", "FWATER1",surface: 1);
			//blood
			BD_ReplaceTextures("BDT_BFA1", "BFALL1",surface: 2);
			BD_ReplaceTextures("BDT_BFA2", "BLOOD1",surface: 2);
			BD_ReplaceTextures("BDT_BFL", "BLOOD1",surface: 1);
			//acid
			BD_ReplaceTextures("BDT_AFA1", "SFALL1",surface: 2);
			BD_ReplaceTextures("BDT_AFA2", "NUKAGE1",surface: 2);
			BD_ReplaceTextures("BDT_AFL", "NUKAGE1",surface: 1);
			//slime 1
			BD_ReplaceTextures("BDT_SFA1", "SLIME01",surface: 2);
			BD_ReplaceTextures("BDT_SFL1", "SLIME01",surface: 1);
			//slime 2
			BD_ReplaceTextures("BDT_SFA2", "SLIME05",surface: 2);
			BD_ReplaceTextures("BDT_SFL2", "SLIME05",surface: 1);
			//Boss brain
			BD_ReplaceTextures("BDT_DBRN", "DBRAIN1",surface: 2);
		}
	}
}

// controls the amount of special effect actors, such as gibs, debris, flames
Class BD_FXAmountControl : EventHandler {
	private bool DebrisCleaning;
	Array <BD_BaseDebris> alldebris;
	Array <BD_BaseDebris> bloodlist;
	Array <BD_BaseDebris> giblist;
	Array <BD_BaseDebris> debrislist;
	Array <BD_BaseDebris> flamelist;
	
	override void NetworkProcess(ConsoleEvent e) {
		if (e.name != "BD_ClearDebris" || !e.isManual)
			return;
		if (e.player != net_arbitrator) {
			if (e.player == consoleplayer)
				Console.Printf("Only the host can activate debris cleanup");
			return;
		}
		if (!DebrisCleaning) {
			Console.Printf("Clearing debris");
			DebrisCleaning = true;
		}
	}	
	
	override void PlayerSpawned(PlayerEvent e) {
		let plr = players[e.PlayerNumber].mo;
		if (!plr)
			return;
		if (!plr.FindInventory("BD_BloodyPrintControl"))
			plr.GiveInventory("BD_BloodyPrintControl",1);
	}
	
	//clear the arrays upon map start
	override void WorldLoaded(WorldEvent e) {
		alldebris.Clear();
		bloodlist.Clear();
		giblist.Clear();
		flamelist.Clear();
		debrislist.Clear();
	}

	//add a thing into a corresponding array when it gets spawned
	override void WorldThingSpawned(WorldEvent e) {
		if (e.thing && e.thing is "BD_BaseDebris") {
			let a = BD_BaseDebris(e.thing);
			if (a) {
				//console.printf("%s",a.sfxtype);
				if (a.sfxtype == 'blood') {
					alldebris.push(a);
					bloodlist.push(a);
				}
				else if (a.sfxtype == 'gibs') {
					alldebris.push(a);
					giblist.push(a);
				}
				//we're not gonna push flames into alldebris array because it's pointless: everything that spawns flames does so continuously. Better simply disable them.
				else if (a.sfxtype == 'flames')
					flamelist.push(a);					
				else if (a.sfxtype == 'debris') {
					alldebris.push(a);
					debrislist.push(a);
				}
			}
		}
	}

	//remove the thing from the array when it's removed
	override void WorldThingDestroyed(WorldEvent e) {
		if (e.Thing is "BD_BaseDebris") {
			let a = BD_BaseDebris(e.thing);
			if (a) {
				alldebris.delete	(alldebris.Find(a));
				if (a.sfxtype == 'blood')
					bloodlist.delete	(bloodlist.Find(a));					
				else if (a.sfxtype == 'gibs')
					giblist.delete		(giblist.Find(a));					
				else if (a.sfxtype == 'flames')
					flamelist.delete	(flamelist.Find(a));					
				else if (a.sfxtype == 'debris')
					debrislist.delete	(debrislist.Find(a));		
			}
		}	
	}

	// continuously check if the number of FX actors 
	// is bigger than the array. if true, delete 
	// the oldest actors
	override void WorldTick() {
		if (DebrisCleaning) {
			while (alldebris.Size() > 0) {
				if (alldebris[0])
					alldebris[0].destroy();
			}
			alldebris.Clear();
			DebrisCleaning = false;
			return;				
		}
		//console.printf("blood array size: %d | gib array size: %d",bloodlist.Size(),giblist.Size());
		while (bloodlist.Size() > bdoom_bloodnum)
			bloodlist[0].destroy();			
		while (giblist.Size() > bdoom_gibnum)
			giblist[0].destroy();			
		while (flamelist.Size() > bdoom_flamesnum) 
			flamelist[0].destroy();			
		while (debrislist.Size() > bdoom_debrisnum) 
			debrislist[0].destroy();
	}
}

//attaches footstep actors to players
class BD_FootstepsInit : EventHandler {
    override void PlayerEntered(PlayerEvent e) {
        let steps = BD_Footsteps(Actor.Spawn("BD_Footsteps"));
		if (steps) {
			steps.Init(players[e.playerNumber].mo);
			steps.fplayer = players[e.playerNumber];
		}
	}
}


///////////////
// Compatibility handlers by 3saster 
//////////////

/*	This searches ANIMDEFS and ANIMATED lumps to see if a given texture name is 
	defined in any of those as an animated texture.
	Used for 3D blood pools sprayed on the floor/ceiling: they quickly disappear
	if they land on an animated texture (including liquids).
*/

Class BD_Animated_Handler : StaticEventHandler
{
	// These must be stored as numbers, in order to get the textures
	// from ANIMATED in between the start and end
	// Oddly, we can convert a TextureID to int, but not the other way
	Array<int> animNums;
	
	bool isAnimated(textureID tex)
	{
		return ( animNums.Find(int(tex)) != animNums.Size() );
	}

	override void OnRegister()
	{
		// ANIMATED
		int currLump = Wads.FindLump("ANIMATED",0,1);
		while( currLump != -1 )
		{
			addANIMATED(currLump);
			currLump = Wads.FindLump("ANIMATED",currLump+1,1);
		}
		
		// ANIMDEFS
		currLump = Wads.FindLump("ANIMDEFS",0,1);
		while( currLump != -1 )
		{
			addANIMDEFS(currLump);
			currLump = Wads.FindLump("ANIMDEFS",currLump+1,1);
		}
	}
	
	void addANIMATED(int lump)
	{
		string data = Wads.ReadLump(lump);
		// Read each record
		for(int pos = 0; data.ByteAt(pos) != 255; pos += 23 )
		{
			string start = data.Mid(pos+10,9);
			string end   = data.Mid(pos+1 ,9);
			
			int texStart = int(TexMan.CheckForTexture(start, TexMan.Type_Any));
			int texEnd   = int(TexMan.CheckForTexture(end,   TexMan.Type_Any));
				
			// If animated texture exists and is not in array, add it
			if( texStart > 0 && texEnd > 0 && texStart != texEnd )
				for(int i = texStart; i <= texEnd; i++)
				{
					if( animNums.Find(i) == animNums.Size() )
						animNums.Push(i);
				}
		}
	}
	
	void addANIMDEFS(int lump)
	{
		string data = Wads.ReadLump(lump);
		// Delete comments
		while(data.IndexOf("//") != -1)
		{
			int start = data.IndexOf("//");
			int end   = data.IndexOf("\n",start)+1;
			data.Remove(start,end-start);
		}
		while(data.IndexOf("/*") != -1)
		{
			int start = data.IndexOf("/*");
			int end   = data.IndexOf("*/",start)+2;
			data.Remove(start,end-start);
		}
		// Remove non-space whitespace
		for(int i = 0; i <= 31; i++)
			data.Replace(string.format("%c",i)," ");
		data.Replace(string.format("%c",127)," ");
		// Remove superflous spaces
		string cleandata = data;
		cleandata.Replace("  "," ");
		while(data != cleandata)
		{
			data = cleandata;
			cleandata.Replace("  "," ");
		}
		
		// Tokenize
		Array<String> tokens;
		data.Split(tokens, " ");
		
		// Search for token after texture/flat
		int i = 0;
		while(i < tokens.Size())
		{
			// texture.flat appears as next token; skip that
			if(tokens[i] ~== "warp" || tokens[i] ~== "warp2")
				i += 2;
			// Found an animated texture; read "pic" stuff until another token is found
			else if(tokens[i] ~== "texture" || tokens[i] ~== "flat")
			{
				while( i < tokens.Size() && !(tokens[i] ~== "pic") )
					i++;
				while( i < tokens.Size() && tokens[i] ~== "pic" )
				{
					int texture = int(TexMan.CheckForTexture(tokens[i+1], TexMan.Type_Any));
					if( texture > 0 && animNums.Find(texture) == animNums.Size() )
						animNums.Push(texture);
					i += 4;
				}
			}
			else
				i++;
		}
	}
	
}


// This eventhandler checks for DEHACKED modified monsters in three ways:
// 1. Thing XX
// 2. Frame XX
// 3. Pointer XX
// False positives are possible (false negatives shouldn't be), but should be fairly rare
Class BD_DEHACKED_Handler : StaticEventHandler
{
	// List of likely modified actors
	Array<string> dehackedActors;

	// Was this actor likely modified by DEHACKED?
	bool isDehacked(string classname)
	{
		// Special handling for Hell Knight...
		if(classname ~== "HellKnight")
		{
			return (dehackedActors.Find(classname) != dehackedActors.Size());
		}
		else
		{
			class<Actor> cls = classname;
			for(int i=0; i<dehackedActors.Size(); i++)
			{
				// Must be done this way to check for inheritance
				if(cls && cls is dehackedActors[i])
					return true;
			}
			return false;
		}
	}
	
	override void OnRegister()
	{
		setConstants();
		
		int currLump = Wads.FindLump("DEHACKED",0,1);
		while( currLump != -1 )
		{
			addDEHACKED(currLump);
			currLump = Wads.FindLump("DEHACKED",currLump+1,1);
		}
		/*
		console.printf("-------------------------------");
		for(int i=0; i<dehackedActors.Size(); i++)
			console.printf("%s", dehackedActors[i]);
		console.printf("-------------------------------");
		*/
	}
	
	void addDEHACKED(int lump)
	{
		string data = Wads.ReadLump(lump);
		// Delete comments
		while(data.IndexOf("#") != -1)
		{
			int start = data.IndexOf("#");
			int end   = data.IndexOf("\n",start);
			data.Remove(start,end-start);
		}
		// Split Lines
		Array<String> lines;
		data.Split(lines, "\n");
		
		// Parse each line
		for(int i=0; i<lines.Size(); i++)
		{
			// Remove superflous spaces
			string cleandata = lines[i];
			cleandata.Replace("  "," ");
			while(lines[i] != cleandata)
			{
				lines[i] = cleandata;
				cleandata.Replace("  "," ");
			}
			// Remove leading whitespace
			while( lines[i].length() > 0 && lines[i].Left(1) == " " )
				lines[i].Remove(0,1);
			// Tokenize
			Array<String> tokens;
			lines[i].Split(tokens, " ");
			if( tokens.Size() >= 2) // Thing XX, etc.
			{
				int num = tokens[1].ToInt(10);
				// not a proper number; skip
				if (num < 0)
					continue;
				// Check the number isn't actually 0, since a failed conversion also returns 0
				if (num == 0)
				{
					string s = tokens[1].."1";
					if( s.ToInt(10) == 0 )
						continue;
				}

				if ( tokens[0] ~== "Thing" )
				{
					if( dehackedActors.Find(InfoNames[num]) == dehackedActors.Size() )
						dehackedActors.Push(InfoNames[num]);
				}
				else if ( tokens[0] ~== "Frame" )
				{
					string state = num < 1076 ? StateMap[num] : 'Deh_Actor_250';
					if( dehackedActors.Find(state) == dehackedActors.Size() )
						dehackedActors.Push(state);
				}
				else if ( tokens[0] ~== "Pointer" )
				{
					num = CodePConv[num];
					string state = num < 1076 ? StateMap[num] : 'Deh_Actor_250';
					if( dehackedActors.Find(state) == dehackedActors.Size() )
						dehackedActors.Push(state);
				}
			}
			if( tokens.Size() >= 3 && tokens[0] ~== "Text" && tokens[1] ~== "4" && tokens[1] ~== "4" ) // "Text 4 4" to change a sprite name
			{
				if( i+1<lines.Size() )
				{
					string modActors = spriteMapping.At( lines[i+1].Left(4).MakeUpper() );
					if( modActors.Length () > 0)
					{
						Array<String> actors;
						modActors.Split(actors, ",");
						for(int i=0; i<actors.Size(); i++)
						{
							if( dehackedActors.Find(actors[i]) == dehackedActors.Size() )
								dehackedActors.Push(actors[i]);
						}
					}
				}
			}
		}
	}
}

